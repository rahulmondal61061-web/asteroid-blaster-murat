<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Murat's Asteroid Shooter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #080816;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            flex-direction: column;
            padding: 20px;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), 0 0 50px rgba(0, 255, 255, 0.3);
            border: 4px solid #00ffff;
            background: linear-gradient(145deg, #0d0d1e, #1a1a2e);
            border-radius: 10px;
            overflow: hidden;
            max-width: 90vw;
            max-height: 90vh;
            aspect-ratio: 16 / 9; /* Maintain a consistent game aspect ratio */
            width: 100%;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #info-bar {
            width: 100%;
            max-width: 90vw;
            margin-top: 20px;
            text-align: center;
            font-size: 10px;
            color: #ffcc00;
            text-shadow: 0 0 5px #ffcc00;
        }

        #llm-section {
            width: 100%;
            max-width: 800px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            padding: 10px;
            background-color: #1a1a2e;
            border-radius: 8px;
            border: 1px solid #00ffff55;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.2);
        }

        #debrief-button {
            transition: all 0.1s ease;
        }

        #debrief-button:active {
            box-shadow: 0 2px #cc7a00;
            transform: translateY(2px);
        }

        #debriefing-output {
            margin-top: 15px;
            padding: 10px;
            border-left: 3px solid #00ffcc;
            background-color: #1a1a2e;
            color: #ffffff;
            font-size: 10px;
            white-space: pre-wrap;
            text-align: left;
            width: 100%;
            box-sizing: border-box;
        }

        #loading-spinner {
            font-size: 10px;
            color: #00ffcc;
        }

        .controls {
            margin-top: 15px;
            font-size: 8px;
            color: #00ffaa;
            text-shadow: 0 0 5px #00ffaa;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            #info-bar {
                font-size: 14px;
            }
            .controls {
                font-size: 12px;
            }
            #debriefing-output {
                 font-size: 12px;
            }
            #game-container {
                width: 800px; /* Max width for desktop */
                height: 450px;
            }
        }
    </style>
</head>
<body>

    <h1>üöÄ MURAT'S ASTEROID BLASTER üëæ</h1>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <div id="info-bar">
        <span id="score-display">Score: 0</span> | 
        <span id="lives-display">Lives: 3</span>
    </div>

    <!-- New LLM section -->
    <div id="llm-section">
        <button id="debrief-button" onclick="game.requestDebriefing()" style="display:none; margin-top: 15px; padding: 10px 20px; font-size: 10px; background-color: #ff9900; color: #080816; border: none; border-radius: 5px; cursor: pointer; text-shadow: none; box-shadow: 0 4px #cc7a00;">
            ‚ú® Analyze Mission Debriefing
        </button>
        <div id="loading-spinner" style="display:none; color: #00ffcc; font-size: 12px; margin-top: 10px;">
            Analyzing mission data...
        </div>
        <div id="debriefing-output">
            <!-- Debriefing text will go here -->
        </div>
    </div>
    
    <div class="controls">
        Use ‚¨ÜÔ∏è (Up) to thrust, ‚¨ÖÔ∏è / ‚û°Ô∏è (Left/Right) to turn, and **SPACE** to shoot!
    </div>

    <script>
        // Global Constants and Setup
        const CANVAS = document.getElementById('game-canvas');
        const CTX = CANVAS.getContext('2d');
        const SCORE_DISPLAY = document.getElementById('score-display');
        const LIVES_DISPLAY = document.getElementById('lives-display');
        const FRICTION = 0.99;
        const ROTATION_SPEED = 0.05;
        const THRUST_POWER = 0.05;
        const SHIP_SIZE = 20;
        const MAX_ASTEROIDS = 10;
        const FPS = 60;
        const FRAME_DURATION = 1000 / FPS;

        let lastFrameTime = 0;
        let game;
        
        // --- GEMINI API Configuration ---
        const GEMINI_MODEL = "gemini-2.5-flash-preview-05-20";
        const API_KEY = ""; // Placeholder for Canvas environment
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
        const MAX_RETRIES = 3;
        const DEBRIEF_BUTTON = document.getElementById('debrief-button');
        const DEBRIEF_OUTPUT = document.getElementById('debriefing-output');
        const LOADING_SPINNER = document.getElementById('loading-spinner');


        // --- Utility Functions ---

        /**
         * Converts degrees to radians.
         * @param {number} deg - Angle in degrees.
         * @returns {number} Angle in radians.
         */
        const degToRad = (deg) => deg / 180 * Math.PI;

        /**
         * Handles canvas resizing to be fully responsive.
         */
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            CANVAS.width = container.clientWidth;
            CANVAS.height = container.clientHeight;
            if (game) {
                game.width = CANVAS.width;
                game.height = CANVAS.height;
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // --- LLM Integration Functions ---

        /**
         * Fetches data with exponential backoff retry logic.
         * @param {string} url - The API URL.
         * @param {object} options - Fetch options (method, headers, body).
         * @param {number} retryCount - Current retry attempt (starts at 0).
         * @returns {Promise<object>} The JSON response.
         */
        async function fetchWithBackoff(url, options, retryCount = 0) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("API Call failed:", error);
                if (retryCount < MAX_RETRIES) {
                    const delay = Math.pow(2, retryCount) * 1000 + Math.random() * 1000;
                    console.warn(`Retrying in ${delay / 1000}s... (Attempt ${retryCount + 1})`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithBackoff(url, options, retryCount + 1);
                } else {
                    throw new Error("API call failed after multiple retries.");
                }
            }
        }

        /**
         * Generates a creative debriefing based on the player's final score.
         * @param {number} score - The player's final score.
         */
        async function generateDebriefing(score) {
            // Updated user query to include the name 'Murat'
            const userQuery = `The pilot, designated 'Murat', just finished an 8-bit asteroid shooter game with a final score of ${score}. Write a one-paragraph, creative post-mission debriefing report. The report should adopt a classic 80s arcade, sci-fi military tone. Reference the pilot's name and analyze their score. Reference the high score if the score is greater than 1000, or a dramatic failure if the score is less than 500.`;

            const systemPrompt = "You are the Automated Star Command Debriefing System (A-SCDS). Your tone is formal, serious, and full of 8-bit military jargon.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                config: {
                    temperature: 0.8
                }
            };

            DEBRIEF_BUTTON.disabled = true;
            LOADING_SPINNER.style.display = 'block';
            DEBRIEF_OUTPUT.textContent = '';


            try {
                const response = await fetchWithBackoff(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const text = response.candidates?.[0]?.content?.parts?.[0]?.text || "ERROR: Command analysis failed. Mission status: Unknown.";
                
                // Format the output
                DEBRIEF_OUTPUT.innerHTML = `<span style="color:#ff9900;">[A-SCDS REPORT FOR PILOT MURAT]</span><br>${text.replace(/\n/g, '<br>')}`;

            } catch (error) {
                DEBRIEF_OUTPUT.textContent = 'ERROR: Failed to establish contact with Star Command.';
                console.error("Gemini API Error:", error);
            } finally {
                LOADING_SPINNER.style.display = 'none';
                DEBRIEF_BUTTON.style.display = 'none'; // Hide button after successful generation
                DEBRIEF_BUTTON.disabled = false;
            }
        }


        // --- Game Object Classes ---

        /**
         * Represents the Player Ship.
         */
        class Ship {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = SHIP_SIZE / 2;
                this.angle = 0; // In radians
                this.vx = 0;
                this.vy = 0;
                this.isThrusting = false;
                this.rotation = 0; // -1 (left), 1 (right), 0 (none)
                this.canShoot = true;
                this.blinkTimer = 0; // For invulnerability blinking
            }

            draw() {
                // Blink effect when invulnerable
                if (this.blinkTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
                    return; // Skip drawing to create blink effect
                }

                CTX.save();
                CTX.translate(this.x, this.y);
                CTX.rotate(this.angle);

                // Draw the main ship triangle
                CTX.strokeStyle = '#00ffff';
                CTX.lineWidth = 2;
                CTX.beginPath();
                // Nose
                CTX.moveTo(this.radius, 0);
                // Bottom left
                CTX.lineTo(-this.radius * 0.75, this.radius * 0.75);
                // Bottom right
                CTX.lineTo(-this.radius * 0.75, -this.radius * 0.75);
                CTX.closePath();
                CTX.stroke();
                
                // Draw engine flame when thrusting
                if (this.isThrusting) {
                    CTX.fillStyle = 'orange';
                    CTX.beginPath();
                    CTX.moveTo(-this.radius * 0.75, -this.radius * 0.4);
                    CTX.lineTo(-this.radius * 1.5 - (Math.random() * 5), 0); // Random length for flame effect
                    CTX.lineTo(-this.radius * 0.75, this.radius * 0.4);
                    CTX.fill();
                }

                CTX.restore();
            }

            update(game) {
                // Rotation
                this.angle += this.rotation * ROTATION_SPEED;

                // Thrust
                if (this.isThrusting) {
                    this.vx += THRUST_POWER * Math.cos(this.angle);
                    this.vy += THRUST_POWER * Math.sin(this.angle);
                }

                // Friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // Movement
                this.x += this.vx;
                this.y += this.vy;

                // Screen wrapping
                if (this.x < 0) this.x = game.width;
                if (this.x > game.width) this.x = 0;
                if (this.y < 0) this.y = game.height;
                if (this.y > game.height) this.y = 0;
                
                // Handle invulnerability timer
                if (this.blinkTimer > 0) {
                    this.blinkTimer -= FRAME_DURATION;
                    if (this.blinkTimer < 0) this.blinkTimer = 0;
                }
            }

            respawn(game) {
                this.x = game.width / 2;
                this.y = game.height / 2;
                this.angle = 0;
                this.vx = 0;
                this.vy = 0;
                this.blinkTimer = 3000; // 3 seconds of invulnerability
            }

            isInvulnerable() {
                return this.blinkTimer > 0;
            }
        }

        /**
         * Represents a Bullet fired by the ship.
         */
        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.radius = 2;
                this.speed = 10;
                this.vx = this.speed * Math.cos(angle);
                this.vy = this.speed * Math.sin(angle);
                this.life = 60 * 2; // Bullet lasts for 2 seconds (120 frames)
            }

            draw() {
                CTX.fillStyle = '#ff3333';
                CTX.beginPath();
                CTX.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                CTX.fill();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }

            isOffScreen(game) {
                return this.x < 0 || this.x > game.width || this.y < 0 || this.y > game.height;
            }
        }

        /**
         * Represents an Asteroid.
         */
        class Asteroid {
            constructor(game, x, y, size) {
                this.x = x || Math.random() * game.width;
                this.y = y || Math.random() * game.height;
                this.size = size || 3; // 3 (large), 2 (medium), 1 (small)
                this.radius = this.size * 15 + 10;
                
                // Ensure the asteroid doesn't spawn too close to the center initially
                if (this.size === 3 && game.ship && Math.hypot(this.x - game.ship.x, this.y - game.ship.y) < 150) {
                     // If too close, pick a new random edge spawn point
                     const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                     if (edge === 0) this.y = -this.radius;
                     else if (edge === 1) this.x = game.width + this.radius;
                     else if (edge === 2) this.y = game.height + this.radius;
                     else this.x = -this.radius;
                }

                this.speed = Math.random() * 2 + 1;
                const angle = Math.random() * Math.PI * 2;
                this.vx = this.speed * Math.cos(angle);
                this.vy = this.speed * Math.sin(angle);
                this.rotationSpeed = Math.random() * 0.02 - 0.01;
                this.angle = Math.random() * Math.PI * 2;

                // Simple polygon drawing configuration
                this.vertices = Math.floor(Math.random() * 5) + 8; // 8 to 12 vertices
                this.offsets = [];
                for (let i = 0; i < this.vertices; i++) {
                    // Random offset to make it look jagged
                    this.offsets.push(Math.random() * 0.4 + 0.8); 
                }
            }

            draw() {
                CTX.save();
                CTX.translate(this.x, this.y);
                CTX.rotate(this.angle);

                CTX.strokeStyle = '#cccccc';
                CTX.lineWidth = 2;
                CTX.beginPath();
                
                for (let i = 0; i < this.vertices; i++) {
                    const vertexAngle = (i / this.vertices) * Math.PI * 2;
                    const x = this.radius * this.offsets[i] * Math.cos(vertexAngle);
                    const y = this.radius * this.offsets[i] * Math.sin(vertexAngle);
                    
                    if (i === 0) {
                        CTX.moveTo(x, y);
                    } else {
                        CTX.lineTo(x, y);
                    }
                }
                
                CTX.closePath();
                CTX.stroke();

                CTX.restore();
            }

            update(game) {
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.rotationSpeed;

                // Screen wrapping
                const r = this.radius;
                if (this.x < -r) this.x = game.width + r;
                if (this.x > game.width + r) this.x = -r;
                if (this.y < -r) this.y = game.height + r;
                if (this.y > game.height + r) this.y = -r;
            }

            split() {
                if (this.size > 1) {
                    const newSize = this.size - 1;
                    return [
                        new Asteroid(game, this.x, this.y, newSize),
                        new Asteroid(game, this.x, this.y, newSize)
                    ];
                }
                return [];
            }
        }

        // --- Main Game Class ---

        class AsteroidGame {
            constructor() {
                this.width = CANVAS.width;
                this.height = CANVAS.height;
                this.ship = new Ship(this.width / 2, this.height / 2);
                this.asteroids = [];
                this.bullets = [];
                this.keys = {};
                this.score = 0;
                this.lives = 3;
                this.gameOver = false;
                this.asteroidSpawnTimer = 0;
                this.asteroidSpawnRate = 3000; // Time in ms between spawns
                this.lastSpawnTime = Date.now();
                this.ship.respawn(this);
            }

            initListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    // Prevent default spacebar action (scrolling)
                    if (e.code === 'Space') e.preventDefault(); 
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }

            reset() {
                this.score = 0;
                this.lives = 3;
                this.gameOver = false;
                this.asteroids = [];
                this.bullets = [];
                this.ship.respawn(this);
                this.lastSpawnTime = Date.now();
                // Clear LLM output and hide button on reset
                DEBRIEF_BUTTON.style.display = 'none';
                DEBRIEF_BUTTON.disabled = false;
                DEBRIEF_OUTPUT.textContent = '';
                LOADING_SPINNER.style.display = 'none';
            }
            
            checkGameOver() {
                if (this.lives <= 0) {
                    this.gameOver = true;
                    this.drawGameOver();
                    return true;
                }
                return false;
            }

            spawnAsteroid() {
                // Spawn one large asteroid
                this.asteroids.push(new Asteroid(this, null, null, 3)); 
            }
            
            updateScoreAndLives() {
                SCORE_DISPLAY.textContent = `Score: ${this.score}`;
                LIVES_DISPLAY.textContent = `Lives: ${this.lives}`;
            }

            processInput() {
                this.ship.isThrusting = this.keys['ArrowUp'];
                this.ship.rotation = 0;
                if (this.keys['ArrowLeft']) this.ship.rotation = -1;
                if (this.keys['ArrowRight']) this.ship.rotation = 1;

                // Shooting
                if (this.keys['Space'] && this.ship.canShoot && !this.gameOver) {
                    const bulletX = this.ship.x + this.ship.radius * Math.cos(this.ship.angle);
                    const bulletY = this.ship.y + this.ship.radius * Math.sin(this.ship.angle);
                    this.bullets.push(new Bullet(bulletX, bulletY, this.ship.angle));
                    this.ship.canShoot = false; // Implement a simple cooldown
                    setTimeout(() => {
                        if (this.ship) this.ship.canShoot = true;
                    }, 200);
                }
                // Restart on Game Over
                if (this.gameOver && this.keys['Space']) {
                    this.reset();
                }
            }

            updateGameObjects() {
                // Ship update
                this.ship.update(this);

                // Bullets update
                this.bullets = this.bullets.filter(b => b.life > 0 && !b.isOffScreen(this));
                this.bullets.forEach(b => b.update());

                // Asteroids update
                this.asteroids.forEach(a => a.update(this));
            }

            handleCollisions() {
                let newAsteroids = [];
                let collidedBullets = new Set();
                
                // Ship vs Asteroid
                if (!this.ship.isInvulnerable()) {
                    for (let i = 0; i < this.asteroids.length; i++) {
                        const a = this.asteroids[i];
                        const dist = Math.hypot(this.ship.x - a.x, this.ship.y - a.y);
                        if (dist < this.ship.radius + a.radius) {
                            this.lives--;
                            this.ship.respawn(this);
                            break; // Ship can only collide with one asteroid at a time for simplicity
                        }
                    }
                }

                // Bullet vs Asteroid
                for (let i = 0; i < this.bullets.length; i++) {
                    const b = this.bullets[i];
                    for (let j = 0; j < this.asteroids.length; j++) {
                        const a = this.asteroids[j];
                        const dist = Math.hypot(b.x - a.x, b.y - a.y);
                        
                        if (dist < b.radius + a.radius) {
                            collidedBullets.add(b);
                            
                            // Split asteroid and update score
                            newAsteroids.push(...a.split());
                            this.score += a.size * 100;
                            
                            // Remove the hit asteroid (mark for removal by swapping with last element)
                            this.asteroids[j] = this.asteroids[this.asteroids.length - 1];
                            this.asteroids.pop();
                            j--; // Re-check the new asteroid at this index
                            
                            break; // Bullet can only hit one asteroid
                        }
                    }
                }

                // Filter out hit bullets and add new split asteroids
                this.bullets = this.bullets.filter(b => !collidedBullets.has(b));
                this.asteroids.push(...newAsteroids);
            }

            handleSpawning() {
                const now = Date.now();
                if (this.asteroids.length < MAX_ASTEROIDS && now - this.lastSpawnTime > this.asteroidSpawnRate) {
                    this.spawnAsteroid();
                    this.lastSpawnTime = now;
                    // Gradually increase spawn rate slightly
                    if (this.asteroidSpawnRate > 1000) {
                        this.asteroidSpawnRate *= 0.99;
                    }
                }
            }

            draw() {
                // Clear the canvas (space background)
                CTX.fillStyle = '#0d0d1e';
                CTX.fillRect(0, 0, this.width, this.height);

                // Draw game objects
                this.asteroids.forEach(a => a.draw());
                this.bullets.forEach(b => b.draw());
                this.ship.draw();

                // Update info bar
                this.updateScoreAndLives();
            }

            drawGameOver() {
                CTX.fillStyle = 'rgba(0, 0, 0, 0.7)';
                CTX.fillRect(0, 0, this.width, this.height);

                CTX.fillStyle = '#ff0077';
                CTX.textAlign = 'center';
                CTX.font = '30px "Press Start 2P"';
                CTX.fillText('GAME OVER', this.width / 2, this.height / 2 - 20);

                CTX.fillStyle = '#00ffff';
                CTX.font = '12px "Press Start 2P"';
                CTX.fillText(`FINAL SCORE: ${this.score}`, this.width / 2, this.height / 2 + 20);

                CTX.fillStyle = '#ffcc00';
                CTX.font = '10px "Press Start 2P"';
                CTX.fillText('Press SPACE to Restart', this.width / 2, this.height / 2 + 60);
                
                // Show the debriefing button
                DEBRIEF_BUTTON.style.display = 'block';
            }
            
            /**
             * Public method to call the debriefing generator.
             */
            requestDebriefing() {
                 // Trigger the debriefing generation
                 generateDebriefing(this.score);
            }


            gameLoop(timestamp) {
                if (timestamp - lastFrameTime >= FRAME_DURATION) {
                    if (!this.gameOver) {
                        this.processInput();
                        this.handleSpawning();
                        this.updateGameObjects();
                        this.handleCollisions();
                        this.draw();
                        this.checkGameOver();
                    } else {
                        // Still process input to allow restart
                        this.processInput();
                    }
                    lastFrameTime = timestamp;
                }

                requestAnimationFrame(this.gameLoop.bind(this));
            }
        }

        // --- Initialization ---

        window.onload = () => {
            // Initialize canvas size
            resizeCanvas(); 
            
            // Create and start the game
            game = new AsteroidGame();
            game.initListeners();
            game.spawnAsteroid(); // Start with one asteroid
            
            // Start the game loop
            game.gameLoop(0);
        };
    </script>
</body>
</html>
